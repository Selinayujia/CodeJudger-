{
    "title": "ReverseInteger",
    "star": 3,
    "abstract": "Given a 32-bit signed integer, reverse digits of an integer",
    "text": "Approach 1: Pop and Push Digits & Check before Overflow. We can build up the reverse integer one digit at a time. While doing so, we can check beforehand whether or not appending another digit would cause overflow. Reversing an integer can be done similarly to reversing a string.

    We want to repeatedly 'pop' the last digit off of xx and push it to the back of the \text{rev}rev. In the end, \text{rev}rev will be the reverse of the xx.
    
    To 'pop' and 'push' digits without the help of some auxiliary stack/array, we can use math.
    
    //pop operation:
    pop = x % 10;
    x /= 10;
    
    //push operation:
    temp = rev * 10 + pop;
    rev = temp;
    
    c++
    class Solution {
        public:
            int reverse(int x) {
                int rev = 0;
                while (x != 0) {
                    int pop = x % 10;
                    x /= 10;
                    if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;
                    if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;
                    rev = rev * 10 + pop;
                }
                return rev;
            }
        };
    
    java
    class Solution {
        public int reverse(int x) {
            int rev = 0;
            while (x != 0) {
                int pop = x % 10;
                x /= 10;
                if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
                if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
                rev = rev * 10 + pop;
            }
            return rev;
        }
    }
    "
}